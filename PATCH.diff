Binary files /mnt/data/sv45_orig/SistemaVendas/web/__pycache__/app.cpython-311.pyc and /mnt/data/sv45/SistemaVendas/web/__pycache__/app.cpython-311.pyc differ
Binary files /mnt/data/sv45_orig/SistemaVendas/web/__pycache__/db.cpython-311.pyc and /mnt/data/sv45/SistemaVendas/web/__pycache__/db.cpython-311.pyc differ
diff -ruN /mnt/data/sv45_orig/SistemaVendas/web/app.py /mnt/data/sv45/SistemaVendas/web/app.py
--- /mnt/data/sv45_orig/SistemaVendas/web/app.py	2026-02-12 13:12:04.000000000 +0000
+++ /mnt/data/sv45/SistemaVendas/web/app.py	2026-02-12 20:18:54.324088654 +0000
@@ -43,6 +43,10 @@
     CampanhaCombo,
     CampanhaComboItem,
     CampanhaComboResultado,
+    CampanhaRankingMarca,
+    CampanhaRankingMarcaEmp,
+    CampanhaRankingMarcaPremio,
+    CampanhaRankingMarcaResultado,
     VendasResumoPeriodo,
     MetaPrograma,
     MetaProgramaEmp,
@@ -1157,6 +1161,60 @@
             seen.add(v); res.append(v)
     return res
 
+
+def _vendedor_norm(v: str | None) -> str:
+    return (v or "").strip().upper()
+
+
+def _parse_emps_anywhere(param_name: str = "emp") -> list[str]:
+    """L√™ EMP(s) de request.args/form/values em formatos comuns:
+    - emp=101&emp=102
+    - emp[]=101&emp[]=102
+    - emp=101,102
+    - emp[]=101,102
+    """
+    vals: list[str] = []
+
+    # 1) values (GET/POST)
+    for key in (param_name, f"{param_name}[]"):
+        try:
+            vals.extend([str(x) for x in request.values.getlist(key) if str(x).strip()])
+        except Exception:
+            pass
+
+    # 2) fallback: args CSV
+    if not vals:
+        try:
+            raw = request.values.get(param_name) or request.values.get(f"{param_name}[]") or ""
+        except Exception:
+            raw = ""
+        raw = str(raw or "").strip()
+        if raw:
+            vals = [raw]
+
+    out: list[str] = []
+    for v in vals:
+        for part in str(v).split(","):
+            p = _emp_norm(part)
+            if p:
+                out.append(p)
+
+    # unique mantendo ordem
+    seen = set()
+    res: list[str] = []
+    for v in out:
+        if v not in seen:
+            seen.add(v)
+            res.append(v)
+    return res
+
+
+def _parse_action_anywhere() -> str:
+    """L√™ a√ß√£o/action de request.form/values com robustez."""
+    raw = (request.form.get("acao") or request.form.get("action") or request.values.get("acao") or request.values.get("action") or "").strip().lower()
+    return raw
+
+
 def _competencia_fechada(db, emp: str, ano: int, mes: int) -> bool:
     """Retorna True se a compet√™ncia (EMP+ano+mes) estiver marcada como FECHADA."""
     emp = _emp_norm(emp)
@@ -3308,6 +3366,228 @@
                 db.bulk_save_objects(novos)
             db.commit()
 
+# ---------------------------------------------------------------------
+# Campanhas Ranking por Marca (Top N) - c√°lculo e snapshot
+# ---------------------------------------------------------------------
+def _valid_vendedores_set(db) -> set[str]:
+    """Set de vendedores v√°lidos (usuarios.role='vendedor')."""
+    try:
+        rows = db.query(Usuario.username).filter(func.lower(Usuario.role) == "vendedor").all()
+        return {(r[0] or "").strip().upper() for r in rows if r and (r[0] or "").strip()}
+    except Exception:
+        return set()
+
+
+def _campanha_rank_marca_periodo(c: CampanhaRankingMarca, ano: int, mes: int) -> tuple[date, date]:
+    """Retorna [inicio, fim_inclusivo] para c√°lculo da campanha no m√™s alvo."""
+    # Se a campanha tiver compet√™ncia fixa, usamos o m√™s/ano dela; caso contr√°rio, usamos o m√™s selecionado, mas
+    # respeitando o overlap com data_inicio/data_fim.
+    start_mes, end_mes_excl = _periodo_bounds(int(ano), int(mes))
+    fim_mes = end_mes_excl - timedelta(days=1)
+
+    di = getattr(c, "data_inicio", None) or start_mes
+    df = getattr(c, "data_fim", None) or fim_mes
+
+    # interse√ß√£o com o m√™s (evita puxar vendas fora da compet√™ncia exibida)
+    ini = max(di, start_mes)
+    fim = min(df, fim_mes)
+    return ini, fim
+
+
+def _rank_premios_map(db, campanha_id: int) -> dict[int, float]:
+    try:
+        rows = (
+            db.query(CampanhaRankingMarcaPremio.posicao, CampanhaRankingMarcaPremio.valor_premio)
+            .filter(CampanhaRankingMarcaPremio.campanha_id == int(campanha_id))
+            .all()
+        )
+        mp = {int(p): float(v or 0.0) for p, v in rows if p is not None}
+        return mp
+    except Exception:
+        return {}
+
+
+def _rank_emps_scope(db, c: CampanhaRankingMarca) -> list[str] | None:
+    esc = (getattr(c, "escopo_tipo", "") or "GLOBAL").strip().upper()
+    if esc == "EMPS":
+        try:
+            rows = (
+                db.query(CampanhaRankingMarcaEmp.emp)
+                .filter(CampanhaRankingMarcaEmp.campanha_id == int(c.id))
+                .all()
+            )
+            emps = [str(r[0]).strip() for r in rows if r and str(r[0]).strip()]
+            return sorted(set(emps))
+        except Exception:
+            return []
+    # GLOBAL
+    return None
+
+
+def _recalcular_resultados_ranking_marca_para_competencia(db, ano: int, mes: int, emps_scope: list[str] | None = None) -> None:
+    """Recalcula (upsert) resultados de todas campanhas ranking-marca ativas que cruzem a compet√™ncia.
+    - emps_scope (opcional): restringe recalculo somente a campanhas que intersectem estas EMPs (otimiza√ß√£o em relat√≥rios).
+    """
+    ano = int(ano); mes = int(mes)
+
+    # campanhas ativas que cruzam o m√™s ou que tenham compet√™ncia fixa igual
+    start_mes, end_mes_excl = _periodo_bounds(ano, mes)
+    fim_mes = end_mes_excl - timedelta(days=1)
+
+    campanhas = (
+        db.query(CampanhaRankingMarca)
+        .filter(CampanhaRankingMarca.ativo.is_(True))
+        .filter(
+            or_(
+                and_(CampanhaRankingMarca.competencia_ano == ano, CampanhaRankingMarca.competencia_mes == mes),
+                and_(CampanhaRankingMarca.data_inicio <= fim_mes, CampanhaRankingMarca.data_fim >= start_mes),
+            )
+        )
+        .order_by(CampanhaRankingMarca.id.asc())
+        .all()
+    )
+
+    if not campanhas:
+        return
+
+    valid_vendedores = _valid_vendedores_set(db)
+    if not valid_vendedores:
+        # sem usu√°rios cadastrados como vendedor: mant√©m compat (n√£o recalcula)
+        return
+
+    for c in campanhas:
+        marca_norm = (getattr(c, "marca", "") or "").strip().upper()
+        if not marca_norm:
+            continue
+
+        # escopo de EMPs da campanha
+        camp_emps = _rank_emps_scope(db, c)  # None (GLOBAL) ou lista
+        if camp_emps is not None and not camp_emps:
+            # EMPS sem v√≠nculo: nada a fazer
+            continue
+
+        # Se foi passado emps_scope, e a campanha for EMPS, s√≥ recalcula se intersectar (performance em relat√≥rios)
+        if emps_scope and camp_emps is not None:
+            if not (set(camp_emps) & set([str(e) for e in emps_scope])):
+                continue
+
+        ini, fim = _campanha_rank_marca_periodo(c, ano, mes)
+        if fim < ini:
+            continue
+
+        # Premia√ß√£o (Top N)
+        premios_map = _rank_premios_map(db, int(c.id))
+        if not premios_map:
+            # default 1/2/3
+            premios_map = {1: 300.0, 2: 200.0, 3: 100.0}
+
+        # Query agregada: soma vendas por vendedor+emp no per√≠odo e marca
+        q = (
+            db.query(func.upper(Venda.vendedor), Venda.emp, func.coalesce(func.sum(Venda.valor_total), 0.0))
+            .filter(Venda.mov_tipo_movto == "OA")
+            .filter(Venda.movimento >= ini, Venda.movimento <= fim)
+            .filter(func.upper(func.coalesce(func.trim(Venda.marca), "")) == marca_norm)
+        )
+
+        if camp_emps is not None:
+            q = q.filter(Venda.emp.in_([str(e) for e in camp_emps]))
+
+        q = q.group_by(func.upper(Venda.vendedor), Venda.emp)
+
+        rows = q.all()
+
+        # agrega por vendedor (somando EMPs); e escolhe EMP do maior volume (para fechamento por EMP)
+        vend_tot: dict[str, float] = {}
+        vend_emp_best: dict[str, tuple[str, float]] = {}  # vendedor -> (emp, valor)
+        for vend_u, emp_v, total in rows:
+            v = _vendedor_norm(vend_u)
+            if not v or v not in valid_vendedores:
+                continue
+            emp_s = _emp_norm(str(emp_v or ""))
+            val = float(total or 0.0)
+            if val <= 0:
+                continue
+            vend_tot[v] = vend_tot.get(v, 0.0) + val
+            if emp_s:
+                prev = vend_emp_best.get(v)
+                if (prev is None) or (val > prev[1]) or (val == prev[1] and emp_s < prev[0]):
+                    vend_emp_best[v] = (emp_s, val)
+
+        # ranking (desc por total; desempate alfab√©tico)
+        ranking = sorted(vend_tot.items(), key=lambda kv: (-float(kv[1]), kv[0]))
+
+        # Atualiza resultados (upsert) somente para Top N (posi√ß√µes que tem pr√™mio)
+        top_positions = sorted([int(p) for p in premios_map.keys() if int(p) > 0])
+        if not top_positions:
+            continue
+        top_n = max(top_positions)
+
+        now = datetime.utcnow()
+        for idx, (v, tot) in enumerate(ranking[:top_n], start=1):
+            premio = float(premios_map.get(int(idx), 0.0) or 0.0)
+            if premio <= 0:
+                continue
+            emp_attr = None
+            if v in vend_emp_best:
+                emp_attr = vend_emp_best[v][0] or None
+
+            # tenta encontrar registro existente para manter status_pagamento/pago_em
+            rec = (
+                db.query(CampanhaRankingMarcaResultado)
+                .filter(
+                    CampanhaRankingMarcaResultado.campanha_id == int(c.id),
+                    CampanhaRankingMarcaResultado.competencia_ano == ano,
+                    CampanhaRankingMarcaResultado.competencia_mes == mes,
+                    CampanhaRankingMarcaResultado.vendedor == v,
+                    # emp pode variar (atribui√ß√£o); preferimos match por emp_attr quando houver
+                    or_(
+                        CampanhaRankingMarcaResultado.emp == emp_attr,
+                        CampanhaRankingMarcaResultado.emp.is_(None),
+                        emp_attr is None,
+                    ),
+                )
+                .order_by(CampanhaRankingMarcaResultado.id.desc())
+                .first()
+            )
+            if not rec:
+                rec = CampanhaRankingMarcaResultado(
+                    campanha_id=int(c.id),
+                    competencia_ano=ano,
+                    competencia_mes=mes,
+                    emp=emp_attr,
+                    vendedor=v,
+                    status_pagamento="PENDENTE",
+                )
+                db.add(rec)
+
+            # Atualiza m√©tricas (n√£o zera status)
+            rec.emp = emp_attr
+            rec.valor_vendido = float(tot or 0.0)
+            rec.posicao = int(idx)
+            rec.valor_premio = float(premio or 0.0)
+            rec.atualizado_em = now
+
+        # Opcional: n√£o removemos posi√ß√µes antigas automaticamente (evita apagar hist√≥rico por erro de base).
+        # O admin pode apagar manualmente ou recalcular com limpeza se desejar.
+
+    try:
+        db.commit()
+    except Exception:
+        db.rollback()
+        app.logger.exception("Falha ao recalcular ranking marca")
+
+
+def _status_bucket(val: str | None) -> str:
+    s = (val or "").strip().upper()
+    if s in {"PAGO", "PAG", "PAYED"}:
+        return "PAGO"
+    if s in {"A_PAGAR", "APAGAR", "A PAGAR", "A-PAGAR"}:
+        return "A_PAGAR"
+    # default
+    return "PENDENTE"
+
+
+
 
 def _build_campanhas_escolhidas_por_vendedor(campanhas: list[CampanhaQtd], vendedores: list[str]) -> dict[str, list[CampanhaQtd]]:
     """Aplica a regra de prioridade por chave (prefixo+marca): campanha do vendedor substitui campanha geral."""
@@ -3570,6 +3850,12 @@
             })
 
             # -------- Resultados (Tab B/C) --------
+            # garante ranking marca recalculado para esta compet√™ncia (evita tela vazia se admin n√£o recalculou)
+            try:
+                _recalcular_resultados_ranking_marca_para_competencia(db, ano, mes, emps_scope=[emp])
+            except Exception:
+                pass
+
             resultados_qtd = (
                 db.query(CampanhaQtdResultado)
                 .filter(
@@ -3594,6 +3880,19 @@
                 .all()
             )
 
+            resultados_ranking_marca = (
+                db.query(CampanhaRankingMarcaResultado)
+                .filter(
+                    CampanhaRankingMarcaResultado.emp == emp,
+                    CampanhaRankingMarcaResultado.competencia_ano == int(ano),
+                    CampanhaRankingMarcaResultado.competencia_mes == int(mes),
+                    CampanhaRankingMarcaResultado.vendedor.in_([v.strip().upper() for v in vendedores]),
+                    CampanhaRankingMarcaResultado.valor_premio > 0,
+                )
+                .order_by(CampanhaRankingMarcaResultado.posicao.asc().nullslast(), CampanhaRankingMarcaResultado.valor_premio.desc())
+                .all()
+            )
+
 
             # Pr√©-calcula detalhes de COMBO para exibi√ß√£o (leve e sem alterar valores salvos)
             combo_items_by_combo: dict[int, list[CampanhaComboItem]] = {}
@@ -3745,6 +4044,23 @@
                     "status_pagamento": r.status_pagamento,
                     "periodo": f"{r.data_inicio} ‚Üí {r.data_fim}",
                 })
+            # adiciona Ranking por Marca no agrupamento (snapshot salvo)
+            for r in (resultados_ranking_marca or []):
+                v = (r.vendedor or "").strip().upper()
+                by_vend.setdefault(v, []).append({
+                    "tipo": "RANKING_MARCA",
+                    "titulo": "Ranking por Marca",
+                    "marca": "",
+                    "produto": f"Posi√ß√£o {int(r.posicao) if r.posicao is not None else '-'}",
+                    "qtd": None,
+                    "valor_vendido": float(getattr(r, "valor_vendido", 0.0) or 0.0),
+                    "valor_recompensa": float(getattr(r, "valor_premio", 0.0) or 0.0),
+                    "atingiu": 1,
+                    "status_pagamento": getattr(r, "status_pagamento", None),
+                    "periodo": f"{ano}-{mes:02d}",
+                })
+
+
 
 
             # adiciona Itens Parados no agrupamento (como "campanha")
@@ -5636,6 +5952,664 @@
         ok=ok,
     )
 
+# ---------------------------------------------------------------------
+# Admin ‚Äî Campanhas: Ranking por Marca (Top N)
+# ---------------------------------------------------------------------
+@app.route("/admin/campanhas/ranking-marca", methods=["GET", "POST"])
+def admin_campanhas_ranking_marca():
+    red = _login_required()
+    if red:
+        return red
+    red = _admin_required()
+    if red:
+        return red
+
+    hoje = date.today()
+    mes = int(request.values.get("mes") or hoje.month)
+    ano = int(request.values.get("ano") or hoje.year)
+
+    erro = None
+    ok = None
+
+    def _parse_date(s: str) -> date | None:
+        s = (s or "").strip()
+        if not s:
+            return None
+        for fmt in ("%Y-%m-%d", "%d/%m/%Y"):
+            try:
+                return datetime.strptime(s, fmt).date()
+            except Exception:
+                continue
+        return None
+
+    def _parse_premios_text(txt: str) -> dict[int, float]:
+        mp: dict[int, float] = {}
+        for line in (txt or "").splitlines():
+            line = line.strip()
+            if not line:
+                continue
+            # aceita: 1=300, 1:300, 1 300
+            m2 = re.match(r"^(\d+)\s*[:=\s]\s*([0-9]+(?:[\.,][0-9]+)?)$", line)
+            if not m2:
+                continue
+            pos = int(m2.group(1))
+            val = float(m2.group(2).replace(",", "."))
+            if pos > 0 and val >= 0:
+                mp[pos] = val
+        return mp
+
+    with SessionLocal() as db:
+        # op√ß√µes de EMP
+        try:
+            emps_all = [str(r.codigo).strip() for r in db.query(Emp).order_by(Emp.codigo.asc()).all()]
+        except Exception:
+            emps_all = []
+        emps_options = _get_emp_options(emps_all or [])
+
+        if request.method == "POST":
+            acao = (request.form.get("acao") or request.values.get("acao") or "").strip().lower()
+            cid = int(request.form.get("id") or 0) if (request.form.get("id") or "").strip() else 0
+
+            try:
+                if acao in {"criar", "editar"}:
+                    titulo = (request.form.get("titulo") or "").strip()
+                    marca = (request.form.get("marca") or "").strip().upper()
+                    data_inicio = _parse_date(request.form.get("data_inicio") or "")
+                    data_fim = _parse_date(request.form.get("data_fim") or "")
+                    escopo_tipo = (request.form.get("escopo_tipo") or "GLOBAL").strip().upper()
+                    ativo = True if (request.form.get("ativo") or "").lower() in {"1", "true", "on", "yes"} else False
+
+                    comp_ano = (request.form.get("competencia_ano") or "").strip()
+                    comp_mes = (request.form.get("competencia_mes") or "").strip()
+                    comp_ano_i = int(comp_ano) if comp_ano.isdigit() else None
+                    comp_mes_i = int(comp_mes) if comp_mes.isdigit() else None
+                    if comp_mes_i is not None and (comp_mes_i < 1 or comp_mes_i > 12):
+                        comp_mes_i = None
+
+                    if not titulo or not marca or not data_inicio or not data_fim:
+                        raise ValueError("Preencha t√≠tulo, marca, in√≠cio e fim.")
+                    if data_fim < data_inicio:
+                        raise ValueError("Data fim deve ser >= data in√≠cio.")
+                    if escopo_tipo not in {"GLOBAL", "EMPS"}:
+                        escopo_tipo = "GLOBAL"
+
+                    if acao == "criar":
+                        obj = CampanhaRankingMarca(
+                            titulo=titulo,
+                            marca=marca,
+                            data_inicio=data_inicio,
+                            data_fim=data_fim,
+                            competencia_ano=comp_ano_i,
+                            competencia_mes=comp_mes_i,
+                            escopo_tipo=escopo_tipo,
+                            ativo=ativo,
+                        )
+                        db.add(obj)
+                        db.flush()  # para ter id
+                        cid = int(obj.id)
+                    else:
+                        obj = db.query(CampanhaRankingMarca).filter(CampanhaRankingMarca.id == int(cid)).first()
+                        if not obj:
+                            raise ValueError("Campanha n√£o encontrada.")
+                        obj.titulo = titulo
+                        obj.marca = marca
+                        obj.data_inicio = data_inicio
+                        obj.data_fim = data_fim
+                        obj.competencia_ano = comp_ano_i
+                        obj.competencia_mes = comp_mes_i
+                        obj.escopo_tipo = escopo_tipo
+                        obj.ativo = ativo
+                        obj.updated_at = datetime.utcnow()
+
+                        # limpa v√≠nculos/premios para regravar
+                        db.query(CampanhaRankingMarcaEmp).filter(CampanhaRankingMarcaEmp.campanha_id == int(cid)).delete()
+                        db.query(CampanhaRankingMarcaPremio).filter(CampanhaRankingMarcaPremio.campanha_id == int(cid)).delete()
+
+                    # EMPs (se EMPS)
+                    if escopo_tipo == "EMPS":
+                        emps_sel = _parse_emps_anywhere("emp")
+                        emps_sel = [e for e in emps_sel if e in set(emps_all)]
+                        for e in emps_sel:
+                            db.add(CampanhaRankingMarcaEmp(campanha_id=int(cid), emp=e))
+
+                    # Pr√™mios
+                    premios_txt = (request.form.get("premios_texto") or "").strip()
+                    premios = _parse_premios_text(premios_txt)
+                    if not premios:
+                        premios = {1: 300.0, 2: 200.0, 3: 100.0}
+                    for pos, val in sorted(premios.items()):
+                        db.add(CampanhaRankingMarcaPremio(campanha_id=int(cid), posicao=int(pos), valor_premio=float(val)))
+
+                    db.commit()
+                    ok = "‚úÖ Campanha salva."
+                elif acao == "remover":
+                    if not cid:
+                        raise ValueError("ID inv√°lido.")
+                    db.query(CampanhaRankingMarcaResultado).filter(CampanhaRankingMarcaResultado.campanha_id == int(cid)).delete()
+                    db.query(CampanhaRankingMarcaEmp).filter(CampanhaRankingMarcaEmp.campanha_id == int(cid)).delete()
+                    db.query(CampanhaRankingMarcaPremio).filter(CampanhaRankingMarcaPremio.campanha_id == int(cid)).delete()
+                    db.query(CampanhaRankingMarca).filter(CampanhaRankingMarca.id == int(cid)).delete()
+                    db.commit()
+                    ok = "üóëÔ∏è Campanha removida."
+                elif acao == "recalcular":
+                    if not cid:
+                        raise ValueError("ID inv√°lido.")
+                    # recalcula resultados da compet√™ncia selecionada
+                    a = int(request.form.get("ano") or ano)
+                    mth = int(request.form.get("mes") or mes)
+                    # restringe emps_scope ao escopo da campanha (otimiza√ß√£o)
+                    camp = db.query(CampanhaRankingMarca).filter(CampanhaRankingMarca.id == int(cid)).first()
+                    if camp:
+                        camp_emps = _rank_emps_scope(db, camp)
+                        scope = None
+                        if camp_emps is not None:
+                            scope = camp_emps
+                        _recalcular_resultados_ranking_marca_para_competencia(db, a, mth, emps_scope=scope)
+                    ok = "üîÅ Recalculo solicitado."
+                else:
+                    erro = "A√ß√£o inv√°lida."
+            except Exception as ex:
+                db.rollback()
+                erro = str(ex)
+
+        # Lista campanhas + v√≠nculos + pr√™mios
+        campanhas = db.query(CampanhaRankingMarca).order_by(CampanhaRankingMarca.id.desc()).all()
+        emps_map: dict[int, list[str]] = {}
+        premios_map: dict[int, list[dict]] = {}
+        if campanhas:
+            ids = [c.id for c in campanhas]
+            rows = db.query(CampanhaRankingMarcaEmp.campanha_id, CampanhaRankingMarcaEmp.emp).filter(CampanhaRankingMarcaEmp.campanha_id.in_(ids)).all()
+            for cid2, e in rows:
+                emps_map.setdefault(int(cid2), []).append(str(e))
+            rows = db.query(CampanhaRankingMarcaPremio.campanha_id, CampanhaRankingMarcaPremio.posicao, CampanhaRankingMarcaPremio.valor_premio).filter(CampanhaRankingMarcaPremio.campanha_id.in_(ids)).all()
+            for cid2, pos, val in rows:
+                premios_map.setdefault(int(cid2), []).append({"posicao": int(pos), "valor": float(val or 0.0)})
+            for k in premios_map:
+                premios_map[k].sort(key=lambda x: x["posicao"])
+
+    return render_template(
+        "admin_campanhas_ranking_marca.html",
+        ano=ano,
+        mes=mes,
+        erro=erro,
+        ok=ok,
+        emps_options=emps_options,
+        campanhas=campanhas,
+        emps_map=emps_map,
+        premios_map=premios_map,
+    )
+
+
+
+
+# ---------------------------------------------------------------------
+# Fechamento Financeiro (ADMIN) ‚Äî consolidado e detalhes
+# ---------------------------------------------------------------------
+def _fechamento_status_map(db, ano: int, mes: int, emps: list[str]) -> dict[str, str]:
+    """Retorna status financeiro por EMP ('aberto'|'a_pagar'|'pago')."""
+    out: dict[str, str] = {}
+    if not emps:
+        return out
+    try:
+        rows = (
+            db.query(FechamentoMensal.emp, FechamentoMensal.status)
+            .filter(
+                FechamentoMensal.ano == int(ano),
+                FechamentoMensal.mes == int(mes),
+                FechamentoMensal.emp.in_([str(e) for e in emps]),
+            )
+            .all()
+        )
+        for emp, st in rows:
+            e = _emp_norm(str(emp or ""))
+            if e:
+                out[e] = (st or "aberto").strip().lower()
+    except Exception:
+        return out
+    return out
+
+
+def _fechamento_consolidado_por_emp(db, ano: int, mes: int, emps: list[str]) -> list[dict]:
+    """Consolidado financeiro do m√™s por EMP.
+    Retorna lista com chaves:
+      emp, qtd, combo, parados, ranking_marca, total,
+      pendente, a_pagar, pago, devido
+    """
+    ano = int(ano); mes = int(mes)
+    emps = [str(_emp_norm(e)) for e in (emps or []) if str(_emp_norm(e))]
+    if not emps:
+        return []
+
+    # status do fechamento para classificar itens parados
+    fech_status = _fechamento_status_map(db, ano, mes, emps)
+
+    # --------- QTD (resultados) ---------
+    qtd_map = {e: {"PENDENTE": 0.0, "A_PAGAR": 0.0, "PAGO": 0.0, "TOTAL": 0.0} for e in emps}
+    try:
+        rows = (
+            db.query(
+                CampanhaQtdResultado.emp,
+                CampanhaQtdResultado.status_pagamento,
+                func.coalesce(func.sum(CampanhaQtdResultado.valor_recompensa), 0.0),
+            )
+            .filter(
+                CampanhaQtdResultado.competencia_ano == ano,
+                CampanhaQtdResultado.competencia_mes == mes,
+                CampanhaQtdResultado.emp.in_(emps),
+                CampanhaQtdResultado.valor_recompensa > 0,
+            )
+            .group_by(CampanhaQtdResultado.emp, CampanhaQtdResultado.status_pagamento)
+            .all()
+        )
+        for emp, st, total in rows:
+            e = _emp_norm(str(emp or ""))
+            if not e or e not in qtd_map:
+                continue
+            bucket = _status_bucket(st)
+            qtd_map[e][bucket] = float(total or 0.0)
+        for e in emps:
+            qtd_map[e]["TOTAL"] = float(qtd_map[e]["PENDENTE"] + qtd_map[e]["A_PAGAR"] + qtd_map[e]["PAGO"])
+    except Exception:
+        pass
+
+    # --------- COMBO (resultados) ---------
+    combo_map = {e: {"PENDENTE": 0.0, "A_PAGAR": 0.0, "PAGO": 0.0, "TOTAL": 0.0} for e in emps}
+    try:
+        rows = (
+            db.query(
+                CampanhaComboResultado.emp,
+                CampanhaComboResultado.status_pagamento,
+                func.coalesce(func.sum(CampanhaComboResultado.valor_recompensa), 0.0),
+            )
+            .filter(
+                CampanhaComboResultado.competencia_ano == ano,
+                CampanhaComboResultado.competencia_mes == mes,
+                CampanhaComboResultado.emp.in_(emps),
+                CampanhaComboResultado.valor_recompensa > 0,
+            )
+            .group_by(CampanhaComboResultado.emp, CampanhaComboResultado.status_pagamento)
+            .all()
+        )
+        for emp, st, total in rows:
+            e = _emp_norm(str(emp or ""))
+            if not e or e not in combo_map:
+                continue
+            bucket = _status_bucket(st)
+            combo_map[e][bucket] = float(total or 0.0)
+        for e in emps:
+            combo_map[e]["TOTAL"] = float(combo_map[e]["PENDENTE"] + combo_map[e]["A_PAGAR"] + combo_map[e]["PAGO"])
+    except Exception:
+        pass
+
+    # --------- RANKING MARCA (resultados) ---------
+    rank_map = {e: {"PENDENTE": 0.0, "A_PAGAR": 0.0, "PAGO": 0.0, "TOTAL": 0.0} for e in emps}
+    try:
+        rows = (
+            db.query(
+                CampanhaRankingMarcaResultado.emp,
+                CampanhaRankingMarcaResultado.status_pagamento,
+                func.coalesce(func.sum(CampanhaRankingMarcaResultado.valor_premio), 0.0),
+            )
+            .filter(
+                CampanhaRankingMarcaResultado.competencia_ano == ano,
+                CampanhaRankingMarcaResultado.competencia_mes == mes,
+                CampanhaRankingMarcaResultado.emp.in_(emps),
+                CampanhaRankingMarcaResultado.valor_premio > 0,
+            )
+            .group_by(CampanhaRankingMarcaResultado.emp, CampanhaRankingMarcaResultado.status_pagamento)
+            .all()
+        )
+        for emp, st, total in rows:
+            e = _emp_norm(str(emp or ""))
+            if not e or e not in rank_map:
+                continue
+            bucket = _status_bucket(st)
+            rank_map[e][bucket] = float(total or 0.0)
+        for e in emps:
+            rank_map[e]["TOTAL"] = float(rank_map[e]["PENDENTE"] + rank_map[e]["A_PAGAR"] + rank_map[e]["PAGO"])
+    except Exception:
+        pass
+
+    # --------- ITENS PARADOS (c√°lculo ao vivo) ---------
+    par_map = {e: {"PENDENTE": 0.0, "A_PAGAR": 0.0, "PAGO": 0.0, "TOTAL": 0.0} for e in emps}
+    try:
+        start_p, end_p = _periodo_bounds(ano, mes)
+        # join vendas x itens_parados por (emp,codigo==mestre) comparando como string normalizada
+        # Como compara√ß√£o √© por string, evitamos cast no lado da coluna (melhor √≠ndice) e normalizamos mestre no SELECT.
+        rows = (
+            db.query(
+                Venda.emp,
+                func.coalesce(func.sum(Venda.valor_total * (ItemParado.recompensa_pct / 100.0)), 0.0),
+            )
+            .join(ItemParado, and_(ItemParado.emp == Venda.emp, cast(Venda.mestre, String) == cast(ItemParado.codigo, String)))
+            .filter(Venda.emp.in_(emps))
+            .filter(Venda.mov_tipo_movto == "OA")
+            .filter(Venda.movimento >= start_p, Venda.movimento < end_p)
+            .filter(ItemParado.ativo == 1)
+            .group_by(Venda.emp)
+            .all()
+        )
+        for emp, total in rows:
+            e = _emp_norm(str(emp or ""))
+            if not e or e not in par_map:
+                continue
+            val = float(total or 0.0)
+            if val <= 0:
+                continue
+            st = (fech_status.get(e) or "aberto").lower()
+            if st == "pago":
+                par_map[e]["PAGO"] = val
+            elif st == "a_pagar":
+                par_map[e]["A_PAGAR"] = val
+            else:
+                par_map[e]["PENDENTE"] = val
+        for e in emps:
+            par_map[e]["TOTAL"] = float(par_map[e]["PENDENTE"] + par_map[e]["A_PAGAR"] + par_map[e]["PAGO"])
+    except Exception:
+        app.logger.exception("Erro ao calcular itens parados no fechamento")
+
+    # Monta linhas finais
+    linhas: list[dict] = []
+    for e in emps:
+        qtd_total = float(qtd_map[e]["TOTAL"])
+        combo_total = float(combo_map[e]["TOTAL"])
+        par_total = float(par_map[e]["TOTAL"])
+        rank_total = float(rank_map[e]["TOTAL"])
+        total = float(qtd_total + combo_total + par_total + rank_total)
+
+        pendente = float(qtd_map[e]["PENDENTE"] + combo_map[e]["PENDENTE"] + par_map[e]["PENDENTE"] + rank_map[e]["PENDENTE"])
+        a_pagar = float(qtd_map[e]["A_PAGAR"] + combo_map[e]["A_PAGAR"] + par_map[e]["A_PAGAR"] + rank_map[e]["A_PAGAR"])
+        pago = float(qtd_map[e]["PAGO"] + combo_map[e]["PAGO"] + par_map[e]["PAGO"] + rank_map[e]["PAGO"])
+        devido = float(pendente + a_pagar)
+
+        linhas.append({
+            "emp": e,
+            "qtd": qtd_total,
+            "combo": combo_total,
+            "parados": par_total,
+            "ranking_marca": rank_total,
+            "total": total,
+            "pendente": pendente,
+            "a_pagar": a_pagar,
+            "pago": pago,
+            "devido": devido,
+            "status_fechamento": (fech_status.get(e) or "aberto"),
+        })
+
+    # ordena por EMP num√©rico quando poss√≠vel
+    linhas.sort(key=lambda r: (_emp_to_int_safe(r["emp"]), r["emp"]))
+    return linhas
+
+
+def _fechamento_detalhes_por_vendedor(db, ano: int, mes: int, emp: str) -> list[dict]:
+    """Detalha o fechamento por vendedor (EMP + compet√™ncia)."""
+    emp = _emp_norm(emp)
+    if not emp:
+        return []
+
+    # vendedores v√°lidos vinculados √† EMP (role=vendedor + v√≠nculo ativo)
+    valid_vend: set[str] = set()
+    try:
+        # via usuario_emps (preferencial)
+        rows = (
+            db.query(func.upper(Usuario.username))
+            .join(UsuarioEmp, UsuarioEmp.usuario_id == Usuario.id)
+            .filter(func.lower(Usuario.role) == "vendedor")
+            .filter(UsuarioEmp.ativo.is_(True))
+            .filter(UsuarioEmp.emp == emp)
+            .all()
+        )
+        valid_vend = {(r[0] or "").strip().upper() for r in rows if r and (r[0] or "").strip()}
+    except Exception:
+        valid_vend = set()
+
+    if not valid_vend:
+        # fallback legado: usuarios.emp
+        try:
+            rows = (
+                db.query(func.upper(Usuario.username))
+                .filter(func.lower(Usuario.role) == "vendedor")
+                .filter(func.coalesce(Usuario.emp, "") == emp)
+                .all()
+            )
+            valid_vend = {(r[0] or "").strip().upper() for r in rows if r and (r[0] or "").strip()}
+        except Exception:
+            valid_vend = set()
+
+    # QTD / COMBO / RANKING: agregados por vendedor
+    out: dict[str, dict] = {}
+
+    def _ensure(v: str):
+        if v not in out:
+            out[v] = {"vendedor": v, "qtd": 0.0, "combo": 0.0, "parados": 0.0, "ranking_marca": 0.0, "total": 0.0, "itens": []}
+
+    # QTD resultados
+    try:
+        rows = (
+            db.query(CampanhaQtdResultado.vendedor, func.coalesce(func.sum(CampanhaQtdResultado.valor_recompensa), 0.0))
+            .filter(
+                CampanhaQtdResultado.emp == emp,
+                CampanhaQtdResultado.competencia_ano == int(ano),
+                CampanhaQtdResultado.competencia_mes == int(mes),
+                CampanhaQtdResultado.valor_recompensa > 0,
+            )
+            .group_by(CampanhaQtdResultado.vendedor)
+            .all()
+        )
+        for v, tot in rows:
+            vv = _vendedor_norm(v)
+            if valid_vend and vv not in valid_vend:
+                continue
+            _ensure(vv)
+            out[vv]["qtd"] = float(tot or 0.0)
+    except Exception:
+        pass
+
+    # COMBO resultados
+    try:
+        rows = (
+            db.query(CampanhaComboResultado.vendedor, func.coalesce(func.sum(CampanhaComboResultado.valor_recompensa), 0.0))
+            .filter(
+                CampanhaComboResultado.emp == emp,
+                CampanhaComboResultado.competencia_ano == int(ano),
+                CampanhaComboResultado.competencia_mes == int(mes),
+                CampanhaComboResultado.valor_recompensa > 0,
+            )
+            .group_by(CampanhaComboResultado.vendedor)
+            .all()
+        )
+        for v, tot in rows:
+            vv = _vendedor_norm(v)
+            if valid_vend and vv not in valid_vend:
+                continue
+            _ensure(vv)
+            out[vv]["combo"] = float(tot or 0.0)
+    except Exception:
+        pass
+
+    # RANKING marca resultados (atribu√≠dos √† EMP)
+    try:
+        rows = (
+            db.query(CampanhaRankingMarcaResultado.vendedor, func.coalesce(func.sum(CampanhaRankingMarcaResultado.valor_premio), 0.0))
+            .filter(
+                CampanhaRankingMarcaResultado.emp == emp,
+                CampanhaRankingMarcaResultado.competencia_ano == int(ano),
+                CampanhaRankingMarcaResultado.competencia_mes == int(mes),
+                CampanhaRankingMarcaResultado.valor_premio > 0,
+            )
+            .group_by(CampanhaRankingMarcaResultado.vendedor)
+            .all()
+        )
+        for v, tot in rows:
+            vv = _vendedor_norm(v)
+            if valid_vend and vv not in valid_vend:
+                continue
+            _ensure(vv)
+            out[vv]["ranking_marca"] = float(tot or 0.0)
+    except Exception:
+        pass
+
+    # ITENS PARADOS por vendedor (c√°lculo ao vivo)
+    try:
+        start_p, end_p = _periodo_bounds(int(ano), int(mes))
+        rows = (
+            db.query(func.upper(Venda.vendedor), func.coalesce(func.sum(Venda.valor_total * (ItemParado.recompensa_pct / 100.0)), 0.0))
+            .join(ItemParado, and_(ItemParado.emp == Venda.emp, cast(Venda.mestre, String) == cast(ItemParado.codigo, String)))
+            .filter(Venda.emp == emp)
+            .filter(Venda.mov_tipo_movto == "OA")
+            .filter(Venda.movimento >= start_p, Venda.movimento < end_p)
+            .filter(ItemParado.ativo == 1)
+            .group_by(func.upper(Venda.vendedor))
+            .all()
+        )
+        for v, tot in rows:
+            vv = _vendedor_norm(v)
+            if valid_vend and vv not in valid_vend:
+                continue
+            val = float(tot or 0.0)
+            if val <= 0:
+                continue
+            _ensure(vv)
+            out[vv]["parados"] = float(val)
+    except Exception:
+        pass
+
+    # Itens detalhados (lista) ‚Äî para expandir no template
+    # QTD/COMBO/RANKING: pega linhas detalhadas por vendedor (sem N+1)
+    vendedores = sorted(out.keys())
+    if not vendedores:
+        return []
+
+    try:
+        qrows = (
+            db.query(CampanhaQtdResultado.vendedor, CampanhaQtdResultado.titulo, CampanhaQtdResultado.marca, CampanhaQtdResultado.produto_prefixo, CampanhaQtdResultado.valor_recompensa, CampanhaQtdResultado.status_pagamento)
+            .filter(
+                CampanhaQtdResultado.emp == emp,
+                CampanhaQtdResultado.competencia_ano == int(ano),
+                CampanhaQtdResultado.competencia_mes == int(mes),
+                CampanhaQtdResultado.vendedor.in_(vendedores),
+                CampanhaQtdResultado.valor_recompensa > 0,
+            )
+            .all()
+        )
+        for v, titulo, marca, prod, valor, st in qrows:
+            vv = _vendedor_norm(v)
+            _ensure(vv)
+            out[vv]["itens"].append({
+                "tipo": "QTD",
+                "titulo": titulo or "Campanha QTD",
+                "marca": marca or "",
+                "item": prod or "",
+                "valor": float(valor or 0.0),
+                "status_pagamento": st or "PENDENTE",
+            })
+    except Exception:
+        pass
+
+    try:
+        crows = (
+            db.query(CampanhaComboResultado.vendedor, CampanhaComboResultado.titulo, CampanhaComboResultado.marca, CampanhaComboResultado.valor_recompensa, CampanhaComboResultado.status_pagamento)
+            .filter(
+                CampanhaComboResultado.emp == emp,
+                CampanhaComboResultado.competencia_ano == int(ano),
+                CampanhaComboResultado.competencia_mes == int(mes),
+                CampanhaComboResultado.vendedor.in_(vendedores),
+                CampanhaComboResultado.valor_recompensa > 0,
+            )
+            .all()
+        )
+        for v, titulo, marca, valor, st in crows:
+            vv = _vendedor_norm(v)
+            _ensure(vv)
+            out[vv]["itens"].append({
+                "tipo": "COMBO",
+                "titulo": titulo or "Campanha Combo",
+                "marca": marca or "",
+                "item": "KIT",
+                "valor": float(valor or 0.0),
+                "status_pagamento": st or "PENDENTE",
+            })
+    except Exception:
+        pass
+
+    try:
+        rrows = (
+            db.query(CampanhaRankingMarcaResultado.vendedor, CampanhaRankingMarcaResultado.posicao, CampanhaRankingMarcaResultado.valor_vendido, CampanhaRankingMarcaResultado.valor_premio, CampanhaRankingMarcaResultado.status_pagamento)
+            .filter(
+                CampanhaRankingMarcaResultado.emp == emp,
+                CampanhaRankingMarcaResultado.competencia_ano == int(ano),
+                CampanhaRankingMarcaResultado.competencia_mes == int(mes),
+                CampanhaRankingMarcaResultado.vendedor.in_(vendedores),
+                CampanhaRankingMarcaResultado.valor_premio > 0,
+            )
+            .all()
+        )
+        for v, pos, vvnd, premio, st in rrows:
+            vv = _vendedor_norm(v)
+            _ensure(vv)
+            out[vv]["itens"].append({
+                "tipo": "RANKING_MARCA",
+                "titulo": "Ranking por Marca",
+                "marca": "",
+                "item": f"Posi√ß√£o {int(pos) if pos is not None else '-'}",
+                "valor_vendido": float(vvnd or 0.0),
+                "valor": float(premio or 0.0),
+                "status_pagamento": st or "PENDENTE",
+            })
+    except Exception:
+        pass
+
+    # Itens Parados detalhados: por vendedor+codigo (sem N+1)
+    try:
+        start_p, end_p = _periodo_bounds(int(ano), int(mes))
+        rows = (
+            db.query(func.upper(Venda.vendedor), cast(Venda.mestre, String), func.coalesce(func.sum(Venda.valor_total), 0.0), ItemParado.recompensa_pct)
+            .join(ItemParado, and_(ItemParado.emp == Venda.emp, cast(Venda.mestre, String) == cast(ItemParado.codigo, String)))
+            .filter(Venda.emp == emp)
+            .filter(Venda.mov_tipo_movto == "OA")
+            .filter(Venda.movimento >= start_p, Venda.movimento < end_p)
+            .filter(ItemParado.ativo == 1)
+            .group_by(func.upper(Venda.vendedor), cast(Venda.mestre, String), ItemParado.recompensa_pct)
+            .all()
+        )
+        for v, codigo, base, pct in rows:
+            vv = _vendedor_norm(v)
+            if vv not in out:
+                continue
+            base_v = float(base or 0.0)
+            pct_v = float(pct or 0.0)
+            valor = base_v * (pct_v / 100.0) if base_v > 0 and pct_v > 0 else 0.0
+            if valor <= 0:
+                continue
+            out[vv]["itens"].append({
+                "tipo": "PARADOS",
+                "titulo": "Itens Parados",
+                "marca": "",
+                "item": str(codigo or ""),
+                "valor_base": base_v,
+                "pct": pct_v,
+                "valor": float(valor),
+                "status_pagamento": "-",  # segue fechamento_mensal
+            })
+    except Exception:
+        pass
+
+    # totaliza e ordena
+    res = []
+    for v in sorted(out.keys()):
+        row = out[v]
+        row["total"] = float(row.get("qtd", 0.0) + row.get("combo", 0.0) + row.get("parados", 0.0) + row.get("ranking_marca", 0.0))
+        # ordena itens por maior valor
+        try:
+            row["itens"].sort(key=lambda x: float(x.get("valor") or 0.0), reverse=True)
+        except Exception:
+            pass
+        res.append(row)
+    # ordena por total desc
+    res.sort(key=lambda r: float(r.get("total") or 0.0), reverse=True)
+    return res
+
+
 
 
 @app.route("/admin/fechamento", methods=["GET", "POST"])
@@ -5653,36 +6627,23 @@
     ano = int(request.values.get("ano") or hoje.year)
     mes = int(request.values.get("mes") or hoje.month)
 
-    # multi-EMP: fecha em lote quando selecionar mais de uma EMP
-    # multi-EMP: l√™ tanto querystring (?emp=101&emp=102) quanto POST (inputs hidden name=emp)
-    emps_sel = []
-    try:
-        emps_sel = [str(e).strip() for e in request.values.getlist("emp") if str(e).strip()]
-    except Exception:
-        emps_sel = []
-    if not emps_sel:
-        emps_sel = [str(e).strip() for e in _parse_multi_args("emp") if str(e).strip()]
-    if not emps_sel:
-        # fallback: tenta usar emp √∫nico (mant√©m compatibilidade com vers√µes antigas)
-        emp_single = _emp_norm(request.values.get("emp", ""))
-        emps_sel = [emp_single] if emp_single else []
-
-    msgs: list[str] = []
-    status_por_emp: dict[str, dict] = {}
+    # multi-EMP: aceita emp=101&emp=102, emp[]=101, CSV e POST
+    emps_sel = _parse_emps_anywhere("emp")
 
-    # Normaliza a a√ß√£o vinda do formul√°rio (alguns navegadores/JS podem enviar
-    # varia√ß√µes, ex.: sem underscore, com h√≠fen ou com espa√ßos).
-    acao_raw = (request.form.get("acao") or "").strip().lower()
+    # A√ß√£o robusta (form/values): acao/action
+    acao_raw = _parse_action_anywhere()
     acao = {
         "fechar_a_pagar": "fechar_a_pagar",
         "fechar_apagar": "fechar_a_pagar",
         "fechar-a-pagar": "fechar_a_pagar",
         "a_pagar": "fechar_a_pagar",
+        "a pagar": "fechar_a_pagar",
         "fechar_pago": "fechar_pago",
         "fechar-pago": "fechar_pago",
         "pago": "fechar_pago",
         "reabrir": "reabrir",
         "abrir": "reabrir",
+        "voltar": "reabrir",
     }.get(acao_raw, acao_raw)
 
     with SessionLocal() as db:
@@ -5697,6 +6658,17 @@
             except Exception:
                 emps_all = []
 
+        # Prote√ß√£o: sempre intersecta sele√ß√£o com op√ß√µes v√°lidas
+        if emps_sel:
+            allowed_set = {str(e).strip() for e in (emps_all or []) if str(e).strip()}
+            emps_sel = [str(e).strip() for e in emps_sel if str(e).strip() in allowed_set]
+
+        # Recalcula ranking por marca para a compet√™ncia (para garantir fechamento/relat√≥rios)
+        try:
+            _recalcular_resultados_ranking_marca_para_competencia(db, ano, mes, emps_scope=emps_sel or None)
+        except Exception:
+            app.logger.exception("Falha ao recalcular ranking marca no fechamento")
+
         if request.method == "POST" and acao in {"fechar_a_pagar", "fechar_pago", "reabrir"}:
             if not emps_sel:
                 msgs.append("‚ö†Ô∏è Selecione ao menos 1 EMP para fechar/reabrir.")
@@ -5733,7 +6705,7 @@
                                 rec.status = alvo_status
                         else:
                             rec.fechado = False
-                            rec.fechado_em = datetime.utcnow()  # mant√©m n√£o-nulo
+                            rec.fechado_em = None
                             if hasattr(rec, "status"):
                                 rec.status = "aberto"
                         updated_count += 1
@@ -5752,35 +6724,69 @@
                 else:
                     if not msgs:
                         msgs.append("‚ö†Ô∏è Nenhuma EMP v√°lida para atualizar.")
-        # Status para tela
-        for emp in (emps_sel or []):
-            emp = _emp_norm(emp)
-            if not emp:
-                continue
-            fechado = False
-            fechado_em = None
-            status_fin = "aberto"
-            try:
-                rec = (
-                    db.query(FechamentoMensal)
-                    .filter(
-                        FechamentoMensal.emp == emp,
-                        FechamentoMensal.ano == int(ano),
-                        FechamentoMensal.mes == int(mes),
-                    )
-                    .first()
+    # Status para tela
+    for emp in (emps_sel or []):
+        emp = _emp_norm(emp)
+        if not emp:
+            continue
+        fechado = False
+        fechado_em = None
+        status_fin = "aberto"
+        try:
+            rec = (
+                db.query(FechamentoMensal)
+                .filter(
+                    FechamentoMensal.emp == emp,
+                    FechamentoMensal.ano == int(ano),
+                    FechamentoMensal.mes == int(mes),
                 )
-                if rec:
-                    if getattr(rec, "status", None):
-                        status_fin = rec.status
-                    if rec.fechado:
-                        fechado = True
-                        fechado_em = rec.fechado_em
-            except Exception:
-                fechado = False
-            status_por_emp[emp] = {"fechado": fechado, "fechado_em": fechado_em, "status": status_fin}
+                .first()
+            )
+            if rec:
+                if getattr(rec, "status", None):
+                    status_fin = rec.status
+                if rec.fechado:
+                    fechado = True
+                    fechado_em = rec.fechado_em
+        except Exception:
+            fechado = False
 
-    emps_options = _get_emp_options(emps_all)
+        status_por_emp[emp] = {"fechado": fechado, "fechado_em": fechado_em, "status": status_fin}
+
+    # Consolidado financeiro por EMP (QTD/Combo/Parados/Ranking Marca)
+    consolidado = []
+    try:
+        consolidado = _fechamento_consolidado_por_emp(db, ano, mes, emps_sel or [])
+    except Exception:
+        app.logger.exception("Erro ao montar consolidado do fechamento")
+        consolidado = []
+
+    # Exporta√ß√£o Excel (GET) ‚Äî usa os filtros atuais
+    if request.method == "GET" and (request.args.get("export") or "").strip() in {"1", "true", "True", "yes"}:
+        try:
+            import pandas as _pd
+            from io import BytesIO as _BytesIO
+
+            df = _pd.DataFrame(consolidado or [])
+            cols = ["emp", "qtd", "combo", "parados", "ranking_marca", "total", "pendente", "a_pagar", "pago", "devido", "status_fechamento"]
+            df = df[[c for c in cols if c in df.columns]]
+
+            buf = _BytesIO()
+            with _pd.ExcelWriter(buf, engine="openpyxl") as writer:
+                df.to_excel(writer, sheet_name="Consolidado", index=False)
+            buf.seek(0)
+            filename = f"fechamento_{int(ano)}_{int(mes):02d}.xlsx"
+            return send_file(
+                buf,
+                as_attachment=True,
+                download_name=filename,
+                mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
+            )
+        except Exception:
+            app.logger.exception("Erro ao exportar Excel do fechamento")
+            flash("N√£o foi poss√≠vel exportar o Excel agora.", "warning")
+
+        emps_options = _get_emp_options(emps_all)
 
     return render_template(
         "admin_fechamento.html",
@@ -5790,9 +6796,107 @@
         emps_sel=emps_sel,
         emps_options=emps_options,
         status_por_emp=status_por_emp,
+        consolidado=consolidado,
         msgs=msgs,
     )
 
+@app.get("/admin/fechamento/detalhes")
+def admin_fechamento_detalhes():
+    """Drill-down do fechamento (ADMIN): por EMP -> vendedores -> itens."""
+    red = _admin_required()
+    if red:
+        return red
+
+    hoje = datetime.now()
+    ano = int(request.args.get("ano") or hoje.year)
+    mes = int(request.args.get("mes") or hoje.month)
+    emp = _emp_norm(request.args.get("emp") or "")
+
+    if not emp:
+        flash("Informe a EMP para ver detalhes.", "warning")
+        return redirect(url_for("admin_fechamento", ano=ano, mes=mes))
+
+    with SessionLocal() as db:
+        # Seguran√ßa: EMP precisa existir nas op√ß√µes do admin (cadastro) ou ter vendas no per√≠odo
+        try:
+            emps_all = [str(r.codigo).strip() for r in db.query(Emp).all()]
+        except Exception:
+            emps_all = []
+        if emp not in set(emps_all):
+            try:
+                emps_periodo = set(_get_emps_com_vendas_no_periodo(ano, mes) or [])
+            except Exception:
+                emps_periodo = set()
+            if emp not in emps_periodo:
+                flash("EMP inv√°lida para detalhes.", "warning")
+                return redirect(url_for("admin_fechamento", ano=ano, mes=mes))
+
+        # garante resultados de ranking marca atualizados
+        try:
+            _recalcular_resultados_ranking_marca_para_competencia(db, ano, mes, emps_scope=[emp])
+        except Exception:
+            pass
+
+        detalhes = _fechamento_detalhes_por_vendedor(db, ano, mes, emp)
+
+        # Export Excel
+        if (request.args.get("export") or "").strip() in {"1", "true", "True", "yes"}:
+            try:
+                import pandas as _pd
+                from io import BytesIO as _BytesIO
+
+                rows_flat = []
+                for d in (detalhes or []):
+                    rows_flat.append({
+                        "vendedor": d.get("vendedor"),
+                        "qtd": d.get("qtd", 0.0),
+                        "combo": d.get("combo", 0.0),
+                        "parados": d.get("parados", 0.0),
+                        "ranking_marca": d.get("ranking_marca", 0.0),
+                        "total": d.get("total", 0.0),
+                    })
+                df = _pd.DataFrame(rows_flat or [])
+                buf = _BytesIO()
+                with _pd.ExcelWriter(buf, engine="openpyxl") as writer:
+                    df.to_excel(writer, sheet_name="Vendedores", index=False)
+
+                    # segunda aba: itens detalhados
+                    itens_flat = []
+                    for d in (detalhes or []):
+                        for it in (d.get("itens") or []):
+                            itens_flat.append({
+                                "vendedor": d.get("vendedor"),
+                                "tipo": it.get("tipo"),
+                                "titulo": it.get("titulo"),
+                                "marca": it.get("marca"),
+                                "item": it.get("item"),
+                                "valor_vendido": it.get("valor_vendido", None),
+                                "valor_base": it.get("valor_base", None),
+                                "pct": it.get("pct", None),
+                                "valor": it.get("valor", 0.0),
+                                "status_pagamento": it.get("status_pagamento"),
+                            })
+                    df2 = _pd.DataFrame(itens_flat or [])
+                    if not df2.empty:
+                        df2.to_excel(writer, sheet_name="Itens", index=False)
+
+                buf.seek(0)
+                filename = f"fechamento_{emp}_{int(ano)}_{int(mes):02d}.xlsx"
+                return send_file(buf, as_attachment=True, download_name=filename, mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
+            except Exception:
+                app.logger.exception("Erro ao exportar detalhes do fechamento")
+                flash("N√£o foi poss√≠vel exportar o Excel agora.", "warning")
+
+    return render_template(
+        "admin_fechamento_detalhes.html",
+        emp=emp,
+        ano=ano,
+        mes=mes,
+        detalhes=detalhes,
+    )
+
+
+
 
 @app.route("/admin/campanhas", methods=["GET", "POST"])
 def admin_campanhas_qtd():
diff -ruN /mnt/data/sv45_orig/SistemaVendas/web/db.py /mnt/data/sv45/SistemaVendas/web/db.py
--- /mnt/data/sv45_orig/SistemaVendas/web/db.py	2026-02-10 16:17:22.000000000 +0000
+++ /mnt/data/sv45/SistemaVendas/web/db.py	2026-02-12 20:20:08.853646527 +0000
@@ -654,6 +654,102 @@
     )
 
 
+
+
+
+# =========================
+# Campanha Ranking por Marca (Top N) ‚Äî premia√ß√£o por coloca√ß√£o
+# =========================
+class CampanhaRankingMarca(Base):
+    __tablename__ = "campanhas_ranking_marca"
+
+    id = Column(Integer, primary_key=True)
+
+    titulo = Column(String(200), nullable=False, default="")
+    marca = Column(String(120), nullable=False, index=True)
+
+    data_inicio = Column(Date, nullable=False, index=True)
+    data_fim = Column(Date, nullable=False, index=True)
+
+    # Opcional: compet√™ncia fixa (se preenchido, prevalece para c√°lculo/relat√≥rios)
+    competencia_ano = Column(Integer, nullable=True, index=True)
+    competencia_mes = Column(Integer, nullable=True, index=True)
+
+    # GLOBAL | EMPS
+    escopo_tipo = Column(String(20), nullable=False, default="GLOBAL", index=True)
+
+    ativo = Column(Boolean, nullable=False, default=True)
+
+    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, server_default=func.now())
+    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow, server_default=func.now())
+
+    __table_args__ = (
+        Index("ix_rank_marca_periodo", "marca", "data_inicio", "data_fim"),
+    )
+
+
+class CampanhaRankingMarcaEmp(Base):
+    __tablename__ = "campanhas_ranking_marca_emps"
+
+    id = Column(Integer, primary_key=True)
+    campanha_id = Column(Integer, nullable=False, index=True)
+    emp = Column(String(30), nullable=False, index=True)
+
+    __table_args__ = (
+        UniqueConstraint("campanha_id", "emp", name="uq_rank_marca_emp"),
+        Index("ix_rank_marca_emps_emp", "emp"),
+    )
+
+
+class CampanhaRankingMarcaPremio(Base):
+    __tablename__ = "campanhas_ranking_marca_premios"
+
+    id = Column(Integer, primary_key=True)
+    campanha_id = Column(Integer, nullable=False, index=True)
+    posicao = Column(Integer, nullable=False)
+    valor_premio = Column(Float, nullable=False, default=0.0)
+
+    __table_args__ = (
+        UniqueConstraint("campanha_id", "posicao", name="uq_rank_marca_premio"),
+        Index("ix_rank_marca_premios_campanha", "campanha_id"),
+    )
+
+
+class CampanhaRankingMarcaResultado(Base):
+    __tablename__ = "campanhas_ranking_marca_resultados"
+
+    id = Column(Integer, primary_key=True)
+    campanha_id = Column(Integer, nullable=False, index=True)
+
+    competencia_ano = Column(Integer, nullable=False, index=True)
+    competencia_mes = Column(Integer, nullable=False, index=True)
+
+    # Para auditoria/fechamento por EMP: usamos a EMP "atribu√≠da" ao vendedor no per√≠odo
+    emp = Column(String(30), nullable=True, index=True)
+
+    vendedor = Column(String(80), nullable=False, index=True)
+
+    valor_vendido = Column(Float, nullable=False, default=0.0)
+    posicao = Column(Integer, nullable=True)
+    valor_premio = Column(Float, nullable=False, default=0.0)
+
+    status_pagamento = Column(String(20), nullable=False, default="PENDENTE")
+    pago_em = Column(DateTime, nullable=True)
+
+    atualizado_em = Column(DateTime, nullable=False, default=datetime.utcnow)
+
+    __table_args__ = (
+        UniqueConstraint(
+            "campanha_id",
+            "competencia_ano",
+            "competencia_mes",
+            "emp",
+            "vendedor",
+            name="uq_rank_marca_resultado",
+        ),
+        Index("ix_rank_marca_res_emp_comp", "emp", "competencia_ano", "competencia_mes"),
+        Index("ix_rank_marca_res_vendedor_comp", "vendedor", "competencia_ano", "competencia_mes"),
+    )
 class VendasResumoPeriodo(Base):
     """Resumo mensal manual/importado (ex.: ano passado) por vendedor e EMP.
 
@@ -909,6 +1005,72 @@
             conn.execute(text("ALTER TABLE fechamento_mensal ADD COLUMN IF NOT EXISTS status varchar(20) DEFAULT 'aberto';"))
             conn.execute(text("CREATE INDEX IF NOT EXISTS ix_fechamento_mensal_status ON fechamento_mensal (status);"))
 
+
+            # Campanhas Ranking por Marca (Top N) ‚Äî tabelas novas
+            conn.execute(text("""
+                CREATE TABLE IF NOT EXISTS campanhas_ranking_marca (
+                    id SERIAL PRIMARY KEY,
+                    titulo VARCHAR(200) NOT NULL,
+                    marca VARCHAR(120) NOT NULL,
+                    data_inicio DATE NOT NULL,
+                    data_fim DATE NOT NULL,
+                    competencia_ano INTEGER,
+                    competencia_mes INTEGER,
+                    escopo_tipo VARCHAR(20) NOT NULL DEFAULT 'GLOBAL',
+                    ativo BOOLEAN NOT NULL DEFAULT TRUE,
+                    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
+                    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
+                );
+            """))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_marca ON campanhas_ranking_marca (marca);"))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_periodo ON campanhas_ranking_marca (data_inicio, data_fim);"))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_comp ON campanhas_ranking_marca (competencia_ano, competencia_mes);"))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_escopo ON campanhas_ranking_marca (escopo_tipo);"))
+
+            conn.execute(text("""
+                CREATE TABLE IF NOT EXISTS campanhas_ranking_marca_emps (
+                    id SERIAL PRIMARY KEY,
+                    campanha_id INTEGER NOT NULL,
+                    emp VARCHAR(30) NOT NULL,
+                    CONSTRAINT uq_rank_marca_emp UNIQUE (campanha_id, emp)
+                );
+            """))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_emps_campanha ON campanhas_ranking_marca_emps (campanha_id);"))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_emps_emp ON campanhas_ranking_marca_emps (emp);"))
+
+            conn.execute(text("""
+                CREATE TABLE IF NOT EXISTS campanhas_ranking_marca_premios (
+                    id SERIAL PRIMARY KEY,
+                    campanha_id INTEGER NOT NULL,
+                    posicao INTEGER NOT NULL,
+                    valor_premio DOUBLE PRECISION NOT NULL DEFAULT 0,
+                    CONSTRAINT uq_rank_marca_premio UNIQUE (campanha_id, posicao)
+                );
+            """))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_premios_campanha ON campanhas_ranking_marca_premios (campanha_id);"))
+
+            conn.execute(text("""
+                CREATE TABLE IF NOT EXISTS campanhas_ranking_marca_resultados (
+                    id SERIAL PRIMARY KEY,
+                    campanha_id INTEGER NOT NULL,
+                    competencia_ano INTEGER NOT NULL,
+                    competencia_mes INTEGER NOT NULL,
+                    emp VARCHAR(30),
+                    vendedor VARCHAR(80) NOT NULL,
+                    valor_vendido DOUBLE PRECISION NOT NULL DEFAULT 0,
+                    posicao INTEGER,
+                    valor_premio DOUBLE PRECISION NOT NULL DEFAULT 0,
+                    status_pagamento VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
+                    pago_em TIMESTAMP,
+                    atualizado_em TIMESTAMP NOT NULL DEFAULT NOW(),
+                    CONSTRAINT uq_rank_marca_resultado UNIQUE (campanha_id, competencia_ano, competencia_mes, emp, vendedor)
+                );
+            """))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_res_emp_comp ON campanhas_ranking_marca_resultados (emp, competencia_ano, competencia_mes);"))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_res_vendedor_comp ON campanhas_ranking_marca_resultados (vendedor, competencia_ano, competencia_mes);"))
+            conn.execute(text("CREATE INDEX IF NOT EXISTS ix_rank_marca_res_status ON campanhas_ranking_marca_resultados (status_pagamento);"))
+
+
             # Bancos mais antigos podem ter criado `status` como ENUM ou com restri√ß√µes.
             # Neste caso, o valor 'a_pagar' pode n√£o existir e a atualiza√ß√£o falha silenciosamente.
             # Tentamos adicionar o valor ao ENUM, se for aplic√°vel, sem derrubar a aplica√ß√£o.
diff -ruN /mnt/data/sv45_orig/SistemaVendas/web/sql/campanhas_ranking_marca.sql /mnt/data/sv45/SistemaVendas/web/sql/campanhas_ranking_marca.sql
--- /mnt/data/sv45_orig/SistemaVendas/web/sql/campanhas_ranking_marca.sql	1970-01-01 00:00:00.000000000 +0000
+++ /mnt/data/sv45/SistemaVendas/web/sql/campanhas_ranking_marca.sql	2026-02-12 20:14:57.535510932 +0000
@@ -0,0 +1,59 @@
+-- Campanha Ranking por Marca (Top N)
+-- Seguro para rodar no Supabase: cria tabelas/√≠ndices se n√£o existirem.
+
+CREATE TABLE IF NOT EXISTS campanhas_ranking_marca (
+  id SERIAL PRIMARY KEY,
+  titulo VARCHAR(200) NOT NULL,
+  marca VARCHAR(120) NOT NULL,
+  data_inicio DATE NOT NULL,
+  data_fim DATE NOT NULL,
+  competencia_ano INTEGER,
+  competencia_mes INTEGER,
+  escopo_tipo VARCHAR(20) NOT NULL DEFAULT 'GLOBAL',
+  ativo BOOLEAN NOT NULL DEFAULT TRUE,
+  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
+  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
+);
+
+CREATE INDEX IF NOT EXISTS ix_rank_marca_marca ON campanhas_ranking_marca (marca);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_periodo ON campanhas_ranking_marca (data_inicio, data_fim);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_comp ON campanhas_ranking_marca (competencia_ano, competencia_mes);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_escopo ON campanhas_ranking_marca (escopo_tipo);
+
+CREATE TABLE IF NOT EXISTS campanhas_ranking_marca_emps (
+  id SERIAL PRIMARY KEY,
+  campanha_id INTEGER NOT NULL,
+  emp VARCHAR(30) NOT NULL,
+  CONSTRAINT uq_rank_marca_emp UNIQUE (campanha_id, emp)
+);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_emps_campanha ON campanhas_ranking_marca_emps (campanha_id);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_emps_emp ON campanhas_ranking_marca_emps (emp);
+
+CREATE TABLE IF NOT EXISTS campanhas_ranking_marca_premios (
+  id SERIAL PRIMARY KEY,
+  campanha_id INTEGER NOT NULL,
+  posicao INTEGER NOT NULL,
+  valor_premio DOUBLE PRECISION NOT NULL DEFAULT 0,
+  CONSTRAINT uq_rank_marca_premio UNIQUE (campanha_id, posicao)
+);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_premios_campanha ON campanhas_ranking_marca_premios (campanha_id);
+
+CREATE TABLE IF NOT EXISTS campanhas_ranking_marca_resultados (
+  id SERIAL PRIMARY KEY,
+  campanha_id INTEGER NOT NULL,
+  competencia_ano INTEGER NOT NULL,
+  competencia_mes INTEGER NOT NULL,
+  emp VARCHAR(30),
+  vendedor VARCHAR(80) NOT NULL,
+  valor_vendido DOUBLE PRECISION NOT NULL DEFAULT 0,
+  posicao INTEGER,
+  valor_premio DOUBLE PRECISION NOT NULL DEFAULT 0,
+  status_pagamento VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
+  pago_em TIMESTAMP,
+  atualizado_em TIMESTAMP NOT NULL DEFAULT NOW(),
+  CONSTRAINT uq_rank_marca_resultado UNIQUE (campanha_id, competencia_ano, competencia_mes, emp, vendedor)
+);
+
+CREATE INDEX IF NOT EXISTS ix_rank_marca_res_emp_comp ON campanhas_ranking_marca_resultados (emp, competencia_ano, competencia_mes);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_res_vendedor_comp ON campanhas_ranking_marca_resultados (vendedor, competencia_ano, competencia_mes);
+CREATE INDEX IF NOT EXISTS ix_rank_marca_res_status ON campanhas_ranking_marca_resultados (status_pagamento);
diff -ruN /mnt/data/sv45_orig/SistemaVendas/web/templates/admin_campanhas_ranking_marca.html /mnt/data/sv45/SistemaVendas/web/templates/admin_campanhas_ranking_marca.html
--- /mnt/data/sv45_orig/SistemaVendas/web/templates/admin_campanhas_ranking_marca.html	1970-01-01 00:00:00.000000000 +0000
+++ /mnt/data/sv45/SistemaVendas/web/templates/admin_campanhas_ranking_marca.html	2026-02-12 20:14:32.720278076 +0000
@@ -0,0 +1,242 @@
+{% extends "base.html" %}
+{% from "partials/multiselect.html" import multiselect %}
+
+{% block title %}Campanhas ‚Äî Ranking por Marca{% endblock %}
+
+{% block extra_head %}
+<style>
+  .page-title{font-weight:800; letter-spacing:-.3px}
+  .subtitle{color:var(--bs-secondary-color)}
+  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
+  textarea.form-control{min-height:120px}
+</style>
+{% endblock %}
+
+{% block content %}
+<div class="container py-4">
+
+  <div class="d-flex flex-wrap justify-content-between align-items-start gap-2 mb-3">
+    <div>
+      <h3 class="m-0 page-title">üèÅ Campanhas ‚Äî Ranking por Marca (Top N)</h3>
+      <div class="subtitle mt-1">Premia√ß√£o fixa por coloca√ß√£o (1¬∫,2¬∫,3¬∫...). ADMIN apenas.</div>
+    </div>
+    <div class="d-flex gap-2">
+      <a class="btn btn-outline-secondary btn-sm" href="{{ url_for('admin_fechamento') }}">Fechamento</a>
+      <a class="btn btn-outline-secondary btn-sm" href="{{ url_for('relatorios_campanhas') }}">Relat√≥rio de Campanhas</a>
+    </div>
+  </div>
+
+  {% if erro %}<div class="alert alert-danger">{{ erro }}</div>{% endif %}
+  {% if ok %}<div class="alert alert-success">{{ ok }}</div>{% endif %}
+
+  <div class="card shadow-sm mb-3">
+    <div class="card-body">
+      <h5 class="m-0">Criar campanha</h5>
+      <div class="subtitle small mt-1">Dica: se n√£o preencher pr√™mios, o default √© 1=300, 2=200, 3=100.</div>
+
+      <form method="post" class="mt-3">
+        <input type="hidden" name="acao" value="criar">
+
+        <div class="row g-2">
+          <div class="col-md-6">
+            <label class="form-label">T√≠tulo</label>
+            <input class="form-control" name="titulo" placeholder="Ranking MAGNETRON Fevereiro" required>
+          </div>
+          <div class="col-md-3">
+            <label class="form-label">Marca</label>
+            <input class="form-control mono" name="marca" placeholder="MAGNETRON" required>
+          </div>
+          <div class="col-md-3">
+            <label class="form-label">Escopo</label>
+            <select class="form-select" name="escopo_tipo">
+              <option value="GLOBAL" selected>GLOBAL (geral)</option>
+              <option value="EMPS">EMPS (selecionar EMPs)</option>
+            </select>
+          </div>
+
+          <div class="col-md-3">
+            <label class="form-label">Data in√≠cio</label>
+            <input class="form-control" type="date" name="data_inicio" required>
+          </div>
+          <div class="col-md-3">
+            <label class="form-label">Data fim</label>
+            <input class="form-control" type="date" name="data_fim" required>
+          </div>
+
+          <div class="col-md-3">
+            <label class="form-label">Compet√™ncia (ano)</label>
+            <input class="form-control" name="competencia_ano" placeholder="{{ ano }}">
+          </div>
+          <div class="col-md-3">
+            <label class="form-label">Compet√™ncia (m√™s)</label>
+            <input class="form-control" name="competencia_mes" placeholder="{{ mes }}">
+          </div>
+
+          <div class="col-md-6">
+            {{ multiselect("emp", emps_options or [], [], label="EMPs (se escopo=EMPS)", placeholder="Selecione EMP(s)") }}
+          </div>
+
+          <div class="col-md-6">
+            <label class="form-label">Pr√™mios (um por linha)</label>
+            <textarea class="form-control mono" name="premios_texto" placeholder="1=300\n2=200\n3=100"></textarea>
+            <div class="form-text">Formatos aceitos: <span class="mono">1=300</span>, <span class="mono">1:300</span> ou <span class="mono">1 300</span>.</div>
+          </div>
+
+          <div class="col-12 d-flex align-items-center gap-3 mt-2">
+            <div class="form-check">
+              <input class="form-check-input" type="checkbox" name="ativo" id="ativoNew" checked>
+              <label class="form-check-label" for="ativoNew">Ativo</label>
+            </div>
+            <button class="btn btn-primary" type="submit">Salvar</button>
+          </div>
+        </div>
+      </form>
+    </div>
+  </div>
+
+  <div class="card shadow-sm">
+    <div class="card-body">
+      <h5 class="m-0">Campanhas cadastradas</h5>
+      <div class="subtitle small mt-1">Editar (regrava v√≠nculos/pr√™mios), remover, ou recalcular resultados para a compet√™ncia.</div>
+
+      {% if not campanhas %}
+        <div class="alert alert-warning mt-3 mb-0">Nenhuma campanha cadastrada.</div>
+      {% else %}
+        <div class="accordion mt-3" id="accRankMarca">
+          {% for c in campanhas %}
+            {% set cid = c.id %}
+            {% set emps = (emps_map.get(cid) or []) %}
+            {% set premios = (premios_map.get(cid) or []) %}
+            <div class="accordion-item">
+              <h2 class="accordion-header" id="h{{ cid }}">
+                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c{{ cid }}" aria-expanded="false" aria-controls="c{{ cid }}">
+                  <b class="me-2">#{{ cid }}</b> {{ c.titulo }} ‚Äî <span class="mono ms-2">{{ c.marca }}</span>
+                  {% if not c.ativo %}<span class="badge text-bg-secondary ms-2">INATIVA</span>{% endif %}
+                  <span class="badge text-bg-info ms-2">{{ (c.escopo_tipo or 'GLOBAL')|upper }}</span>
+                </button>
+              </h2>
+              <div id="c{{ cid }}" class="accordion-collapse collapse" aria-labelledby="h{{ cid }}" data-bs-parent="#accRankMarca">
+                <div class="accordion-body">
+                  <div class="row g-2">
+                    <div class="col-md-6">
+                      <div class="small text-muted">Per√≠odo</div>
+                      <div>{{ c.data_inicio }} ‚Üí {{ c.data_fim }}</div>
+                      <div class="small text-muted mt-2">Compet√™ncia fixa</div>
+                      <div>{{ c.competencia_mes or '-' }}/{{ c.competencia_ano or '-' }}</div>
+                    </div>
+                    <div class="col-md-6">
+                      <div class="small text-muted">EMPs (escopo)</div>
+                      {% if (c.escopo_tipo or '').upper() == 'EMPS' %}
+                        <div class="mono">{{ emps|join(', ') if emps else '‚Äî' }}</div>
+                      {% else %}
+                        <div>GLOBAL (todas)</div>
+                      {% endif %}
+                      <div class="small text-muted mt-2">Pr√™mios</div>
+                      <div class="mono">
+                        {% for p in premios %}
+                          {{ p.posicao }}={{ "%.2f"|format(p.valor) }}{% if not loop.last %}, {% endif %}
+                        {% endfor %}
+                      </div>
+                    </div>
+                  </div>
+
+                  <hr>
+
+                  <div class="row g-2">
+                    <div class="col-md-6">
+                      <form method="post" class="border rounded p-3">
+                        <input type="hidden" name="acao" value="editar">
+                        <input type="hidden" name="id" value="{{ cid }}">
+
+                        <div class="row g-2">
+                          <div class="col-12">
+                            <label class="form-label">T√≠tulo</label>
+                            <input class="form-control" name="titulo" value="{{ c.titulo }}" required>
+                          </div>
+                          <div class="col-6">
+                            <label class="form-label">Marca</label>
+                            <input class="form-control mono" name="marca" value="{{ c.marca }}" required>
+                          </div>
+                          <div class="col-6">
+                            <label class="form-label">Escopo</label>
+                            <select class="form-select" name="escopo_tipo">
+                              <option value="GLOBAL" {% if (c.escopo_tipo or '').upper() == 'GLOBAL' %}selected{% endif %}>GLOBAL</option>
+                              <option value="EMPS" {% if (c.escopo_tipo or '').upper() == 'EMPS' %}selected{% endif %}>EMPS</option>
+                            </select>
+                          </div>
+
+                          <div class="col-6">
+                            <label class="form-label">Data in√≠cio</label>
+                            <input class="form-control" type="date" name="data_inicio" value="{{ c.data_inicio }}" required>
+                          </div>
+                          <div class="col-6">
+                            <label class="form-label">Data fim</label>
+                            <input class="form-control" type="date" name="data_fim" value="{{ c.data_fim }}" required>
+                          </div>
+
+                          <div class="col-6">
+                            <label class="form-label">Compet√™ncia (ano)</label>
+                            <input class="form-control" name="competencia_ano" value="{{ c.competencia_ano or '' }}">
+                          </div>
+                          <div class="col-6">
+                            <label class="form-label">Compet√™ncia (m√™s)</label>
+                            <input class="form-control" name="competencia_mes" value="{{ c.competencia_mes or '' }}">
+                          </div>
+
+                          <div class="col-12">
+                            {{ multiselect("emp", emps_options or [], emps, label="EMPs (se escopo=EMPS)", placeholder="Selecione EMP(s)") }}
+                          </div>
+
+                          <div class="col-12">
+                            <label class="form-label">Pr√™mios (um por linha)</label>
+                            <textarea class="form-control mono" name="premios_texto">{% for p in premios %}{{ p.posicao }}={{ "%.2f"|format(p.valor) }}{% if not loop.last %}\n{% endif %}{% endfor %}</textarea>
+                          </div>
+
+                          <div class="col-12 d-flex align-items-center gap-3">
+                            <div class="form-check">
+                              <input class="form-check-input" type="checkbox" name="ativo" id="ativo{{ cid }}" {% if c.ativo %}checked{% endif %}>
+                              <label class="form-check-label" for="ativo{{ cid }}">Ativo</label>
+                            </div>
+                            <button class="btn btn-primary" type="submit">Salvar altera√ß√µes</button>
+                          </div>
+                        </div>
+                      </form>
+                    </div>
+
+                    <div class="col-md-6">
+                      <div class="border rounded p-3">
+                        <h6 class="m-0">A√ß√µes</h6>
+
+                        <form method="post" class="mt-2 d-flex flex-wrap gap-2">
+                          <input type="hidden" name="acao" value="recalcular">
+                          <input type="hidden" name="id" value="{{ cid }}">
+                          <input type="hidden" name="ano" value="{{ ano }}">
+                          <input type="hidden" name="mes" value="{{ mes }}">
+                          <button class="btn btn-outline-primary" type="submit">Recalcular ({{ mes }}/{{ ano }})</button>
+                        </form>
+
+                        <form method="post" class="mt-2" onsubmit="return confirm('Remover a campanha #{{ cid }}? Isso tamb√©m remove resultados.');">
+                          <input type="hidden" name="acao" value="remover">
+                          <input type="hidden" name="id" value="{{ cid }}">
+                          <button class="btn btn-outline-danger" type="submit">Remover</button>
+                        </form>
+
+                        <div class="text-muted small mt-3">
+                          Resultados aparecem em <b>/relatorios/campanhas</b> e entram no <b>/admin/fechamento</b> quando houver pr√™mio.
+                        </div>
+                      </div>
+                    </div>
+                  </div>
+
+                </div>
+              </div>
+            </div>
+          {% endfor %}
+        </div>
+      {% endif %}
+
+    </div>
+  </div>
+
+</div>
+{% endblock %}
diff -ruN /mnt/data/sv45_orig/SistemaVendas/web/templates/admin_fechamento.html /mnt/data/sv45/SistemaVendas/web/templates/admin_fechamento.html
--- /mnt/data/sv45_orig/SistemaVendas/web/templates/admin_fechamento.html	2026-02-10 16:17:22.000000000 +0000
+++ /mnt/data/sv45/SistemaVendas/web/templates/admin_fechamento.html	2026-02-12 20:11:15.098471856 +0000
@@ -139,5 +139,71 @@
     </div>
   </div>
 
+{% if emps_sel %}
+<div class="card shadow-sm mt-3">
+  <div class="card-body">
+    <div class="d-flex flex-wrap justify-content-between align-items-start gap-2">
+      <div>
+        <h5 class="m-0">Consolidado Financeiro por EMP</h5>
+        <div class="subtitle small mt-1">Somente recompensas <b>&gt; 0</b> no m√™s. Inclui QTD, Combo, Itens Parados e Ranking por Marca.</div>
+      </div>
+      <div class="d-flex gap-2">
+        <a class="btn btn-outline-success btn-sm"
+           href="{{ url_for('admin_fechamento', emp=emps_sel, mes=mes, ano=ano, export=1) }}">
+          Exportar Excel
+        </a>
+      </div>
+    </div>
+
+    {% if not consolidado %}
+      <div class="alert alert-warning mt-3 mb-0">Nenhum valor encontrado para o per√≠odo/EMP(s) selecionadas.</div>
+    {% else %}
+      <div class="table-responsive mt-3">
+        <table class="table table-sm align-middle">
+          <thead>
+            <tr>
+              <th>EMP</th>
+              <th class="text-end">QTD</th>
+              <th class="text-end">Combo</th>
+              <th class="text-end">Parados</th>
+              <th class="text-end">Ranking Marca</th>
+              <th class="text-end">Total</th>
+              <th class="text-end">Pendente</th>
+              <th class="text-end">A pagar</th>
+              <th class="text-end">Pago</th>
+              <th class="text-end">Devido</th>
+              <th class="text-end">Detalhes</th>
+            </tr>
+          </thead>
+          <tbody>
+            {% for r in consolidado %}
+              <tr>
+                <td><b>{{ r.emp }}</b></td>
+                <td class="text-end">{{ "%.2f"|format(r.qtd or 0) }}</td>
+                <td class="text-end">{{ "%.2f"|format(r.combo or 0) }}</td>
+                <td class="text-end">{{ "%.2f"|format(r.parados or 0) }}</td>
+                <td class="text-end">{{ "%.2f"|format(r.ranking_marca or 0) }}</td>
+                <td class="text-end"><b>{{ "%.2f"|format(r.total or 0) }}</b></td>
+                <td class="text-end">{{ "%.2f"|format(r.pendente or 0) }}</td>
+                <td class="text-end">{{ "%.2f"|format(r.a_pagar or 0) }}</td>
+                <td class="text-end">{{ "%.2f"|format(r.pago or 0) }}</td>
+                <td class="text-end"><b>{{ "%.2f"|format(r.devido or 0) }}</b></td>
+                <td class="text-end">
+                  <a class="btn btn-outline-primary btn-sm"
+                     href="{{ url_for('admin_fechamento_detalhes', emp=r.emp, ano=ano, mes=mes) }}">
+                    Ver detalhes
+                  </a>
+                </td>
+              </tr>
+            {% endfor %}
+          </tbody>
+        </table>
+      </div>
+    {% endif %}
+  </div>
+</div>
+{% endif %}
+
+
 </div>
 {% endblock %}
\ No newline at end of file
diff -ruN /mnt/data/sv45_orig/SistemaVendas/web/templates/admin_fechamento_detalhes.html /mnt/data/sv45/SistemaVendas/web/templates/admin_fechamento_detalhes.html
--- /mnt/data/sv45_orig/SistemaVendas/web/templates/admin_fechamento_detalhes.html	1970-01-01 00:00:00.000000000 +0000
+++ /mnt/data/sv45/SistemaVendas/web/templates/admin_fechamento_detalhes.html	2026-02-12 20:13:11.695141624 +0000
@@ -0,0 +1,115 @@
+{% extends "base.html" %}
+
+{% block title %}Fechamento ‚Äî Detalhes EMP {{ emp }} ‚Äî {{ mes }}/{{ ano }}{% endblock %}
+
+{% block extra_head %}
+<style>
+  .page-title{font-weight:800; letter-spacing:-.3px}
+  .subtitle{color:var(--bs-secondary-color)}
+  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
+  .item-row{background: rgba(0,0,0,.02)}
+</style>
+{% endblock %}
+
+{% block content %}
+<div class="container py-4">
+
+  <div class="d-flex flex-wrap justify-content-between align-items-start gap-2 mb-3">
+    <div>
+      <h3 class="m-0 page-title">üìå Detalhes do Fechamento</h3>
+      <div class="subtitle mt-1">EMP <b>{{ emp }}</b> ‚Äî Compet√™ncia: <b>{{ mes }}/{{ ano }}</b></div>
+    </div>
+    <div class="d-flex gap-2">
+      <a class="btn btn-outline-secondary btn-sm" href="{{ url_for('admin_fechamento', emp=emp, ano=ano, mes=mes) }}">Voltar</a>
+      <a class="btn btn-outline-success btn-sm" href="{{ url_for('admin_fechamento_detalhes', emp=emp, ano=ano, mes=mes, export=1) }}">Exportar Excel</a>
+    </div>
+  </div>
+
+  {% if not detalhes %}
+    <div class="alert alert-warning">Sem dados para o per√≠odo/EMP selecionada.</div>
+  {% else %}
+    <div class="card shadow-sm">
+      <div class="card-body">
+        <div class="table-responsive">
+          <table class="table align-middle">
+            <thead>
+              <tr>
+                <th>Vendedor</th>
+                <th class="text-end">QTD</th>
+                <th class="text-end">Combo</th>
+                <th class="text-end">Parados</th>
+                <th class="text-end">Ranking Marca</th>
+                <th class="text-end">Total</th>
+                <th class="text-end">Itens</th>
+              </tr>
+            </thead>
+            <tbody>
+              {% for d in detalhes %}
+                {% set collapse_id = 'itens_' ~ loop.index %}
+                <tr>
+                  <td><b>{{ d.vendedor }}</b></td>
+                  <td class="text-end">{{ "%.2f"|format(d.qtd or 0) }}</td>
+                  <td class="text-end">{{ "%.2f"|format(d.combo or 0) }}</td>
+                  <td class="text-end">{{ "%.2f"|format(d.parados or 0) }}</td>
+                  <td class="text-end">{{ "%.2f"|format(d.ranking_marca or 0) }}</td>
+                  <td class="text-end"><b>{{ "%.2f"|format(d.total or 0) }}</b></td>
+                  <td class="text-end">
+                    <button class="btn btn-outline-primary btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#{{ collapse_id }}" aria-expanded="false" aria-controls="{{ collapse_id }}">
+                      Ver itens ({{ (d.itens or [])|length }})
+                    </button>
+                  </td>
+                </tr>
+                <tr class="collapse item-row" id="{{ collapse_id }}">
+                  <td colspan="7">
+                    {% if not d.itens %}
+                      <div class="text-muted small">Sem itens detalhados.</div>
+                    {% else %}
+                      <div class="table-responsive">
+                        <table class="table table-sm mb-0">
+                          <thead>
+                            <tr>
+                              <th>Tipo</th>
+                              <th>T√≠tulo</th>
+                              <th>Marca</th>
+                              <th>Item</th>
+                              <th class="text-end">Valor vendido</th>
+                              <th class="text-end">Recompensa</th>
+                              <th>Status</th>
+                            </tr>
+                          </thead>
+                          <tbody>
+                            {% for it in d.itens %}
+                              <tr>
+                                <td><span class="badge text-bg-secondary">{{ it.tipo }}</span></td>
+                                <td>{{ it.titulo }}</td>
+                                <td class="mono">{{ it.marca or '' }}</td>
+                                <td class="mono">{{ it.item or '' }}</td>
+                                <td class="text-end">
+                                  {% if it.valor_vendido is defined and it.valor_vendido is not none %}
+                                    {{ "%.2f"|format(it.valor_vendido or 0) }}
+                                  {% elif it.valor_base is defined and it.valor_base is not none %}
+                                    {{ "%.2f"|format(it.valor_base or 0) }}
+                                  {% else %}
+                                    ‚Äî
+                                  {% endif %}
+                                </td>
+                                <td class="text-end"><b>{{ "%.2f"|format(it.valor or 0) }}</b></td>
+                                <td class="small">{{ it.status_pagamento or 'PENDENTE' }}</td>
+                              </tr>
+                            {% endfor %}
+                          </tbody>
+                        </table>
+                      </div>
+                    {% endif %}
+                  </td>
+                </tr>
+              {% endfor %}
+            </tbody>
+          </table>
+        </div>
+      </div>
+    </div>
+  {% endif %}
+
+</div>
+{% endblock %}
